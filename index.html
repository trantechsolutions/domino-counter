<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Domino Counter AI</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Style for the video stream to make it look like a camera viewfinder */
        #video {
            transform: scaleX(-1); /* Mirror the camera feed */
        }
        /* Custom focus-visible styles for better accessibility */
        button:focus-visible, input:focus-visible {
            outline: 2px solid #4f46e5;
            outline-offset: 2px;
        }
        /* Loading spinner animation */
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #4f46e5;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen p-4">

    <div id="app-container" class="w-full max-w-md bg-white rounded-2xl shadow-xl p-6 space-y-6">
        
        <header class="text-center">
            <h1 class="text-3xl font-bold text-gray-800">Domino Counter</h1>
            <p class="text-gray-500">Mexican Train Scorer</p>
        </header>

        <!-- Camera and Canvas Section -->
        <div id="video-container" class="relative bg-gray-900 rounded-lg overflow-hidden border-2 border-gray-200">
            <video id="video" playsinline autoplay muted class="w-full h-auto block"></video>
            <div id="loading-overlay" class="absolute inset-0 bg-gray-900 bg-opacity-75 flex-col items-center justify-center hidden">
                <div class="loader"></div>
                <p class="text-white mt-4">Starting Camera...</p>
            </div>
        </div>

        <!-- Processed Image Feedback -->
        <div id="processed-container" class="bg-gray-200 rounded-lg overflow-hidden hidden">
             <canvas id="processed-canvas" class="w-full h-auto block"></canvas>
        </div>

        <!-- Controls Section -->
        <div id="controls-section">
            <button id="start-button" class="w-full bg-indigo-600 text-white font-bold py-3 px-4 rounded-lg shadow-md hover:bg-indigo-700 transition-all duration-200 ease-in-out transform hover:scale-105 focus:outline-none">
                Start Camera
            </button>
            <button id="scan-button" class="w-full bg-indigo-600 text-white font-bold py-3 px-4 rounded-lg shadow-md hover:bg-indigo-700 transition-all duration-200 ease-in-out transform hover:scale-105 focus:outline-none hidden">
                Scan Domino
            </button>
        </div>

        <!-- Results Display -->
        <div id="results-section" class="grid grid-cols-2 gap-4 text-center hidden">
            <div class="bg-gray-100 p-4 rounded-lg">
                <h2 class="text-sm font-medium text-gray-500">Current Scan</h2>
                <p id="current-count" class="text-4xl font-bold text-indigo-600">0</p>
            </div>
            <div class="bg-gray-100 p-4 rounded-lg">
                <h2 class="text-sm font-medium text-gray-500">Total Score</h2>
                <p id="total-score" class="text-4xl font-bold text-gray-800">0</p>
            </div>
        </div>

        <!-- Action Buttons -->
        <div id="actions-section" class="grid grid-cols-2 gap-4 hidden">
            <button id="add-button" class="w-full bg-green-500 text-white font-bold py-3 px-4 rounded-lg shadow-md hover:bg-green-600 transition-all duration-200">Add to Total</button>
            <button id="reset-button" class="w-full bg-red-500 text-white font-bold py-3 px-4 rounded-lg shadow-md hover:bg-red-600 transition-all duration-200">Reset All</button>
        </div>

        <!-- Instructions -->
        <div class="bg-indigo-50 border-l-4 border-indigo-500 text-indigo-800 p-4 rounded-r-lg">
            <h3 class="font-bold">Tips for Best Results</h3>
            <ul class="list-disc list-inside text-sm mt-2">
                <li>Use a plain, light-colored background.</li>
                <li>Ensure good, even lighting without harsh shadows.</li>
                <li>Scan one domino at a time, holding it steady.</li>
                <li>Fill the frame with the domino for accuracy.</li>
            </ul>
        </div>
    </div>

    <!-- Hidden canvas for processing -->
    <canvas id="hidden-canvas" style="display:none;"></canvas>

<script>
    // DOM Element References
    const video = document.getElementById('video');
    const startButton = document.getElementById('start-button');
    const scanButton = document.getElementById('scan-button');
    const addButton = document.getElementById('add-button');
    const resetButton = document.getElementById('reset-button');
    const loadingOverlay = document.getElementById('loading-overlay');
    
    const hiddenCanvas = document.getElementById('hidden-canvas');
    const processedCanvas = document.getElementById('processed-canvas');
    const processedContainer = document.getElementById('processed-container');
    const hiddenCtx = hiddenCanvas.getContext('2d', { willReadFrequently: true });
    const processedCtx = processedCanvas.getContext('2d');

    const currentCountEl = document.getElementById('current-count');
    const totalScoreEl = document.getElementById('total-score');
    
    const resultsSection = document.getElementById('results-section');
    const actionsSection = document.getElementById('actions-section');

    // App State
    let currentScanValue = 0;
    let totalScore = 0;

    // --- Event Listeners ---
    startButton.addEventListener('click', startCamera);
    scanButton.addEventListener('click', scanDomino);
    
    addButton.addEventListener('click', () => {
        totalScore += currentScanValue;
        currentScanValue = 0;
        updateUI();
        // Clear the processed canvas for the next scan
        processedCtx.clearRect(0, 0, processedCanvas.width, processedCanvas.height);
        processedContainer.classList.add('hidden');
    });

    resetButton.addEventListener('click', () => {
        currentScanValue = 0;
        totalScore = 0;
        updateUI();
        processedCtx.clearRect(0, 0, processedCanvas.width, processedCanvas.height);
        processedContainer.classList.add('hidden');
    });

    // --- Core Functions ---
    async function startCamera() {
        loadingOverlay.classList.remove('hidden');
        loadingOverlay.classList.add('flex');
        startButton.disabled = true;

        try {
            const stream = await navigator.mediaDevices.getUserMedia({
                video: { facingMode: 'environment' } // Prefer rear camera
            });
            video.srcObject = stream;
            video.onloadedmetadata = () => {
                video.play();
                // UI transition
                startButton.classList.add('hidden');
                scanButton.classList.remove('hidden');
                resultsSection.classList.remove('hidden');
                actionsSection.classList.remove('hidden');
                loadingOverlay.classList.add('hidden');
                loadingOverlay.classList.remove('flex');
            };
        } catch (err) {
            console.error("Camera Error:", err);
            alert('Could not access the camera. Please ensure you grant permission and are using a secure (https) connection.');
            loadingOverlay.classList.add('hidden');
            loadingOverlay.classList.remove('flex');
            startButton.disabled = false;
        }
    }

    function updateUI() {
        currentCountEl.textContent = currentScanValue;
        totalScoreEl.textContent = totalScore;
    }
    
    function scanDomino() {
        if (!video.srcObject) {
            alert("Camera not started.");
            return;
        }

        // Match canvas dimensions to the video's intrinsic size
        const w = video.videoWidth;
        const h = video.videoHeight;
        hiddenCanvas.width = w;
        hiddenCanvas.height = h;
        processedCanvas.width = w;
        processedCanvas.height = h;

        // 1. Capture a frame from the video onto the hidden canvas
        hiddenCtx.drawImage(video, 0, 0, w, h);
        
        try {
            // 2. Get image data and process it
            const imageData = hiddenCtx.getImageData(0, 0, w, h);
            const binaryData = processImageToBinary(imageData);

            // 3. Use blob detection to count the dots
            const dotCount = countBlobs(binaryData, w, h);

            // 4. Update application state and UI
            currentScanValue = dotCount;
            updateUI();

            // 5. Display the processed black & white image for user feedback
            const processedImageData = new ImageData(new Uint8ClampedArray(binaryData.data), w, h);
            processedCtx.putImageData(processedImageData, 0, 0);
            processedContainer.classList.remove('hidden');

        } catch (e) {
            console.error("Image Processing Error:", e);
            alert("An error occurred while scanning the image. Please try again.");
        }
    }

    // --- Image Processing & "AI" Logic ---

    /**
     * Converts an image to grayscale and then to a binary (black/white) image
     * based on a dynamic threshold. This is the key step to isolate dots.
     * @param {ImageData} imageData - The raw image data from the canvas.
     * @returns {object} An object containing the binary image data and dimensions.
     */
    function processImageToBinary(imageData) {
        const data = imageData.data;
        const grayData = new Uint8ClampedArray(data.length);
        const histogram = new Array(256).fill(0);

        // First pass: convert to grayscale and build histogram
        for (let i = 0; i < data.length; i += 4) {
            const r = data[i];
            const g = data[i + 1];
            const b = data[i + 2];
            // Using the luminosity method for better grayscale representation
            const gray = Math.round(0.299 * r + 0.587 * g + 0.114 * b);
            grayData[i] = grayData[i + 1] = grayData[i + 2] = gray;
            grayData[i + 3] = 255;
            histogram[gray]++;
        }

        // Otsu's method to find an optimal dynamic threshold
        let total = imageData.width * imageData.height;
        let sum = 0;
        for (let t = 0; t < 256; t++) sum += t * histogram[t];

        let sumB = 0;
        let wB = 0;
        let wF = 0;
        let mB, mF;
        let max = 0;
        let threshold = 0;

        for (let t = 0; t < 256; t++) {
            wB += histogram[t];
            if (wB === 0) continue;
            wF = total - wB;
            if (wF === 0) break;
            sumB += t * histogram[t];
            mB = sumB / wB;
            mF = (sum - sumB) / wF;
            let between = wB * wF * (mB - mF) * (mB - mF);
            if (between > max) {
                max = between;
                threshold = t;
            }
        }
        
        // Second pass: apply threshold to create binary image
        const binary = { data: new Uint8ClampedArray(data.length), width: imageData.width, height: imageData.height };
        for (let i = 0; i < grayData.length; i += 4) {
            // We are looking for dark dots on a light background
            const value = grayData[i] < threshold ? 0 : 255; // 0 for black (dots), 255 for white
            binary.data[i] = binary.data[i + 1] = binary.data[i + 2] = value;
            binary.data[i + 3] = 255;
        }
        return binary;
    }

    /**
     * Counts connected components (blobs) in a binary image. This is our dot counter.
     * @param {object} binaryData - The binary image data object.
     * @param {number} width - The width of the image.
     * @param {number} height - The height of the image.
     * @returns {number} The count of valid dots found.
     */
    function countBlobs(binaryData, width, height) {
        const data = binaryData.data;
        const visited = new Array(width * height).fill(false);
        let blobCount = 0;
        
        // Dynamic blob size filtering based on image resolution
        const totalPixels = width * height;
        const minBlobSize = Math.max(20, Math.round(totalPixels * 0.0003)); // Filter out noise
        const maxBlobSize = Math.round(totalPixels * 0.03);   // Filter out large non-domino objects

        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const index = (y * width + x);
                // Check for a black pixel (potential dot) that hasn't been visited yet
                if (data[index * 4] === 0 && !visited[index]) {
                    let blobSize = 0;
                    const queue = [[x, y]]; // Queue for Breadth-First Search (BFS)
                    visited[index] = true;
                    
                    // Start BFS to find the size of the connected component
                    while (queue.length > 0) {
                        const [cx, cy] = queue.shift();
                        blobSize++;

                        // Check 8 neighboring pixels
                        for (let ny = cy - 1; ny <= cy + 1; ny++) {
                            for (let nx = cx - 1; nx <= cx + 1; nx++) {
                                if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                                    const nIndex = (ny * width + nx);
                                    if (data[nIndex * 4] === 0 && !visited[nIndex]) {
                                        visited[nIndex] = true;
                                        queue.push([nx, ny]);
                                    }
                                }
                            }
                        }
                    }

                    // If the blob size is within our defined range, it's a valid dot
                    if (blobSize > minBlobSize && blobSize < maxBlobSize) {
                        blobCount++;
                    }
                }
            }
        }
        return blobCount;
    }
</script>
</body>
</html>